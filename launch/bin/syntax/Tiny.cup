package syntax;

import java_cup.runtime.*;
import lexicon.AnalizadorLexicoTiny;
import lexicon.LexiconUnit;
import errors.GestionErroresTiny;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((LexiconUnit)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal        INTEGER, ID, INT_T,SUM_OP, SUBS_OP,
                MULT_OP, DIV_OP, MOD_OP, POW_OP, PARENTESIS_OPEN,
                PARENTESIS_CLOSE, BRACKET_OPEN, BRACKET_CLOSE,
                SQ_BRACKET_OPEN, SQ_BRACKET_CLOSE, LESS_OP,
                GREATER_OP, EQUAL_OP, LESS_OR_EQ_OP, GREATER_OR_EQ_OP,
                NOT_EQUAL_OP, BOOLEAN_T, AND_OP, OR_OP, NOT_OP, TRUE, FALSE,
                COMMA, COLON, SEMICOLON, CLASS_T, STRUCT_T, FIELD_ACCESS,
                FUNC_T, POINTER_OP, REFERENCE_OP, NEW_OP, TYPEDEF, DEFINE,
                ASSIGNATION_OP, IF, ELSE, SWITCH, CASE, BREAK,
                DEFAULT, WHILE, FOR, CONTINUE, INPUT_FUNC,
                OUTPUT_FUNC, RETURN, THIS, PUBLIC, PRIVATE, MAIN;

non terminal    S, S1,
                BT, CLASS_EX, CLASS_BODY, CLASS_INIT, VISIBILITY, METHODS, STRUCT_EX, STRUCT_BODY, STRUCT_INIT, DECLARATIONS, DECLARATION,
                FUNCTION, TYPED_FUNCTION, VOID_FUNCTION, ARGUMENT_EX, ARGUMENTS, MORE_ARGUMENTS, FUNCTION_BODY, RETURN_VALUE,
                DEFINE_EX,
                TYPEDEF_EX, TYPE_TYPEDEF,
                ASSIGNATION_INS, EXPRESSION_OR_NEW,
                IF_INS, ELSE_INS,
                SWITCH_INS, CASES_INS, DEFAULT_CASE,
                WHILE_INS, BREAK_INS, CONTINUE_INS,
                FOR_INS, OPTIONAL_EXPRESSION,
                IO_INS, INPUT_INS, OUTPUT_INS,
                MAIN_INS,
                EXPRESSION,
                B0, B1, B2, B3, B4, E0, E1, E2, E3, E4, E5, E6,
                OP_B0, OP_B1, OP_B2, OP_B3, OP_E0_BIN, OP_E0_UN, OP_E1, OP_E2, OP_E3, OP_E4,
                EXPRESSIONS, MORE_EXPRESSIONS, TERMINAL, ID_AND_PARENTHESIS,
                TYPE, ID_OR_IDBRACKETS, OPT_INTEGER, INSTRUCTION, ID_EX, LITERAL;

// Grammar start
S     ::= S1 MAIN_INS ;
S1    ::= S1 BT | S1 FUNCTION | /*EMPTY*/ ;

// Big types
BT                   ::= CLASS_EX | STRUCT_EX | DEFINE_EX | TYPEDEF_EX ;

CLASS_EX             ::= CLASS_T ID BRACKET_OPEN CLASS_BODY BRACKET_CLOSE ;
CLASS_BODY           ::= DECLARATIONS CLASS_INIT ;
CLASS_INIT           ::= ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE METHODS ;
VISIBILITY           ::= PUBLIC | PRIVATE ;
METHODS              ::= METHODS VISIBILITY FUNCTION | /*EMPTY*/ ;

STRUCT_EX            ::= STRUCT_T ID BRACKET_OPEN STRUCT_BODY BRACKET_CLOSE ;
STRUCT_BODY          ::= DECLARATION STRUCT_BODY | STRUCT_INIT ;
STRUCT_INIT          ::= ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;
DECLARATIONS         ::= DECLARATIONS VISIBILITY DECLARATION | /*EMPTY*/ ;
DECLARATION          ::= TYPE ID_OR_IDBRACKETS SEMICOLON ;

// Functions

FUNCTION          ::= TYPED_FUNCTION | VOID_FUNCTION ;
TYPED_FUNCTION    ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE COLON TYPE BRACKET_OPEN FUNCTION_BODY RETURN RETURN_VALUE SEMICOLON BRACKET_CLOSE ;
VOID_FUNCTION     ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY RETURN SEMICOLON BRACKET_CLOSE ;
ARGUMENT_EX       ::= TYPE ID_OR_IDBRACKETS | TYPE REFERENCE_OP ID_OR_IDBRACKETS ;
ARGUMENTS         ::= MORE_ARGUMENTS ARGUMENT_EX | /*EMPTY*/ ; 
MORE_ARGUMENTS    ::= MORE_ARGUMENTS ARGUMENT_EX COMMA | /*EMPTY*/ ;
FUNCTION_BODY     ::= FUNCTION_BODY INSTRUCTION | /*EMPTY*/ ;
RETURN_VALUE      ::= EXPRESSION ;

// Define

DEFINE_EX   ::= DEFINE ID LITERAL SEMICOLON ;

// Typedef

TYPEDEF_EX     ::= TYPEDEF ID TYPE_TYPEDEF SEMICOLON ;
TYPE_TYPEDEF   ::= INT_T | BOOLEAN_T | ID | TYPE_TYPEDEF POINTER_OP | TYPE_TYPEDEF SQ_BRACKET_OPEN OPT_INTEGER SQ_BRACKET_CLOSE ;

// Asignation

ASSIGNATION_INS   ::= TYPE ID_OR_IDBRACKETS ASSIGNATION_OP EXPRESSION_OR_NEW SEMICOLON | EXPRESSION ASSIGNATION_OP EXPRESSION_OR_NEW SEMICOLON ;
EXPRESSION_OR_NEW ::= EXPRESSION | NEW_OP TYPE | NEW_OP ID_AND_PARENTHESIS ;

// If

IF_INS      ::= IF PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ELSE_INS ;
ELSE_INS    ::= ELSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE | /*EMPTY*/ ;

// Switch

SWITCH_INS        ::= SWITCH PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN CASES_INS DEFAULT_CASE BRACKET_CLOSE ;
CASES_INS         ::= CASES_INS CASE PARENTESIS_OPEN LITERAL PARENTESIS_CLOSE COLON FUNCTION_BODY | /*EMPTY*/;
DEFAULT_CASE      ::= DEFAULT COLON FUNCTION_BODY BREAK SEMICOLON ;

// While

WHILE_INS      ::= WHILE PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;
BREAK_INS      ::= BREAK SEMICOLON ;
CONTINUE_INS   ::= CONTINUE SEMICOLON ;

// For

FOR_INS  ::= FOR PARENTESIS_OPEN OPTIONAL_EXPRESSION SEMICOLON EXPRESSION SEMICOLON OPTIONAL_EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;
OPTIONAL_EXPRESSION  ::= EXPRESSION | /*EMPTY*/ ;

// I/O

IO_INS  ::= INPUT_INS | OUTPUT_INS ;
INPUT_INS   ::= INPUT_FUNC PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE SEMICOLON ;
OUTPUT_INS  ::= OUTPUT_FUNC PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE SEMICOLON ;

// Main

MAIN_INS    ::= FUNCTION MAIN PARENTESIS_OPEN PARENTESIS_CLOSE COLON INT_T BRACKET_OPEN FUNCTION_BODY RETURN INTEGER SEMICOLON BRACKET_CLOSE ;

// Boolean and arithmetic expresions

EXPRESSION        ::= B0 ;

B0                ::= B1 OP_B0 B1 | B1 ;
B1                ::= B1 OP_B1 B2 | B2 ;
B2                ::= B2 OP_B2 B3 | B3 ;
B3                ::= OP_B3 B4 | B4 ;
B4                ::= E0 ;
E0                ::= E0 OP_E0_BIN E1 | OP_E0_UN E1 | E1 ;
E1                ::= E1 OP_E1 E2 | E2 ;
E2                ::= E3 OP_E2 E3 | E3 ;
E3                ::= OP_E3 E4 | E4 ;
E4                ::= E5 OP_E4 E5 | E5 ;
E5                ::= E5 SQ_BRACKET_OPEN B0 SQ_BRACKET_CLOSE | E5 PARENTESIS_OPEN EXPRESSIONS PARENTESIS_CLOSE ;
E6                ::= PARENTESIS_OPEN B0 PARENTESIS_CLOSE | TERMINAL ;

OP_B0             ::= LESS_OR_EQ_OP | GREATER_OR_EQ_OP | LESS_OP | GREATER_OP | EQUAL_OP | NOT_EQUAL_OP ;
OP_B1             ::= OR_OP ;
OP_B2             ::= AND_OP ;
OP_B3             ::= NOT_OP ;
OP_E0_BIN         ::= SUM_OP | SUBS_OP ; // Binary operators for E0
OP_E0_UN          ::= SUBS_OP ; // Unitary operators for E0
OP_E1             ::= MULT_OP | DIV_OP | MOD_OP ;
OP_E2             ::= POW_OP ;
OP_E3             ::= POINTER_OP ;
OP_E4             ::= FIELD_ACCESS ;

EXPRESSIONS          ::= MORE_EXPRESSIONS EXPRESSION | /*EMPTY*/ ;
MORE_EXPRESSIONS     ::= MORE_EXPRESSIONS EXPRESSION COMMA | /*EMPTY*/ ;
TERMINAL             ::= LITERAL | ID_EX | ID_AND_PARENTHESIS ;
ID_AND_PARENTHESIS   ::= ID_EX PARENTESIS_OPEN EXPRESSIONS PARENTESIS_CLOSE ;

// Frequently used expresions
TYPE                 ::= INT_T | BOOLEAN_T | ID | TYPE POINTER_OP ;
ID_OR_IDBRACKETS     ::= ID_OR_IDBRACKETS SQ_BRACKET_OPEN OPT_INTEGER SQ_BRACKET_CLOSE | ID ;
OPT_INTEGER          ::= INTEGER | ID | /*EMPTY*/ ;
INSTRUCTION          ::= ASSIGNATION_INS | IF_INS | SWITCH_INS | WHILE_INS | FOR_INS | BREAK_INS | CONTINUE_INS | IO_INS | DECLARATION | SEMICOLON ; // The last semicolon represents an empty instruction
ID_EX                ::= THIS FIELD_ACCESS ID | ID ;
LITERAL              ::= INTEGER | TRUE | FALSE ;