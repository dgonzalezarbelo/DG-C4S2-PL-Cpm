package syntax;

import java_cup.runtime.*;
import lexicon.AnalizadorLexicoTiny;
import lexicon.LexiconUnit;
import errors.GestionErroresTiny;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((LexiconUnit)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal        INTEGER, ID, INT_T,SUM_OP, SUBS_OP,
                MULT_OP, DIV_OP, MOD_OP, POW_OP, PARENTESIS_OPEN,
                PARENTESIS_CLOSE, BRACKET_OPEN, BRACKET_CLOSE,
                SQ_BRACKET_OPEN, SQ_BRACKET_CLOSE, LESS_OP,
                GREATER_OP, EQUAL_OP, LESS_OR_EQ_OP, GREATER_OR_EQ_OP,
                NOT_EQUAL_OP, BOOLEAN_T, AND_OP, OR_OP, NOT_OP, TRUE, FALSE,
                COMMA, COLON, SEMICOLON, CLASS_T, STRUCT_T, FIELD_ACCESS,
                FUNC_T, POINTER_OP, REFERENCE_OP, NEW_OP, TYPEDEF, DEFINE,
                ASSIGNATION_OP, IF, ELSE, SWITCH, CASE, BREAK,
                DEFAULT, WHILE, FOR, CONTINUE, INPUT_FUNC,
                OUTPUT_FUNC, RETURN, THIS, PUBLIC, PRIVATE, MAIN;

non terminal    S, S1,
                DEF, CLASS_DEF, CLASS_INIT, CONSTRUCTORS, CONSTRUCTOR, VISIBILITY, METHODS, STRUCT_DEF, STRUCT_INIT, DECLARATIONS_STRUCT, DECLARATIONS_CLASS, DECLARATION,
                FUNCTION_DEF, TYPED_FUNCTION, VOID_FUNCTION, ARGUMENT, ARGUMENTS, MORE_ARGUMENTS, FUNCTION_BODY, RETURN_VALUE,
                DEFINE_DEF,
                TYPEDEF_DEF, TYPE_TYPEDEF,
                DECLARATION_AND_ASSIGNATION_INS, ASSIGNATION_INS,
                IF_INS, ELSE_INS,
                SWITCH_INS, CASES_INS, DEFAULT_CASE,
                WHILE_INS, BREAK_INS, CONTINUE_INS,
                FOR_INS, OPTIONAL_EXPRESSION,
                IO_INS, INPUT_INS, OUTPUT_INS,
                MAIN_INS,
                EXPRESSION,
                B0, B1, B2, B3, B4, E0, E1, E2, E3, E4, E5, E6,
                OP_B0, OP_B1, OP_B2, OP_B3, OP_E0_BIN, OP_E0_UN, OP_E1, OP_E2, OP_E3, OP_E4,
                EXPRESSIONS, MORE_EXPRESSIONS, TERMINAL,
                TYPE, OPT_INTEGER, SENTENCE, ID_EX, LITERAL;

// Grammar start
S     ::= S1 MAIN_INS ;
S1    ::= S1 DEF ;
S1    ::= /*EMPTY*/ ;

// Definitions
DEF                  ::= CLASS_DEF ;
DEF                  ::= STRUCT_DEF ;
DEF                  ::= DEFINE_DEF ;
DEF                  ::= TYPEDEF_DEF ;
DEF                  ::= FUNCTION_DEF ;

CLASS_DEF            ::= CLASS_T ID BRACKET_OPEN DECLARATIONS_CLASS CLASS_INIT BRACKET_CLOSE ;
CLASS_INIT           ::= CONSTRUCTORS METHODS ;
CONSTRUCTORS         ::= CONSTRUCTORS CONSTRUCTOR ;
CONSTRUCTOR          ::= ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE;
METHODS              ::= METHODS VISIBILITY FUNCTION_DEF ;
METHODS              ::= /*EMPTY*/ ;
VISIBILITY           ::= PUBLIC ;
VISIBILITY           ::= PRIVATE ;
DECLARATIONS_CLASS   ::= DECLARATIONS_CLASS VISIBILITY DECLARATION SEMICOLON ;
DECLARATIONS_CLASS   ::= /*EMPTY*/ ;


STRUCT_DEF           ::= STRUCT_T ID BRACKET_OPEN DECLARATIONS_STRUCT CONSTRUCTORS BRACKET_CLOSE ;
DECLARATIONS_STRUCT  ::= DECLARATIONS_STRUCT DECLARATION SEMICOLON;
DECLARATIONS_STRUCT  ::= /*EMPTY*/ ;

// Functions

FUNCTION_DEF      ::= TYPED_FUNCTION ;
FUNCTION_DEF      ::= VOID_FUNCTION ;
TYPED_FUNCTION    ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE COLON TYPE BRACKET_OPEN FUNCTION_BODY RETURN RETURN_VALUE SEMICOLON BRACKET_CLOSE ;
VOID_FUNCTION     ::= FUNC_T ID PARENTESIS_OPEN ARGUMENTS PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY RETURN SEMICOLON BRACKET_CLOSE ;
ARGUMENTS         ::= MORE_ARGUMENTS ARGUMENT ;
ARGUMENTS         ::= /*EMPTY*/ ; 
MORE_ARGUMENTS    ::= MORE_ARGUMENTS ARGUMENT COMMA ;
MORE_ARGUMENTS    ::= /*EMPTY*/ ;
ARGUMENT          ::= DECLARATION ;
ARGUMENT          ::= TYPE REFERENCE_OP ID ;
ARGUMENT          ::= TYPE REFERENCE_OP ARRAY_CONSTRUCTOR ; 
FUNCTION_BODY     ::= FUNCTION_BODY SENTENCE ;
FUNCTION_BODY     ::= /*EMPTY*/ ;
RETURN_VALUE      ::= EXPRESSION ;

// Define

DEFINE_DEF   ::= DEFINE ID LITERAL SEMICOLON ;

// Typedef

TYPEDEF_DEF    ::= TYPEDEF ID TYPE_TYPEDEF SEMICOLON ;
TYPE_TYPEDEF   ::= INT_T ;
TYPE_TYPEDEF   ::= BOOLEAN_T ;
TYPE_TYPEDEF   ::= ID ;
TYPE_TYPEDEF   ::= TYPE_TYPEDEF POINTER_OP ;
TYPE_TYPEDEF   ::= TYPE_TYPEDEF SQ_BRACKET_OPEN OPT_INTEGER SQ_BRACKET_CLOSE ;

// Asignation

DECLARATION                      ::= TYPE ID ;
DECLARATION                      ::= TYPE ARRAY_CONSTRUCTOR ;
ARRAY_CONSTRUCTOR                ::= ARRAY_CONSTRUCTOR SQ_BRACKET_OPEN OPT_INTEGER SQ_BRACKET_CLOSE ;

DECLARATION_AND_ASSIGNATION_INS  ::= DECLARATION ASSIGNATION_OP EXPRESSION SEMICOLON ;
DECLARATION_AND_ASSIGNATION_INS  ::= DECLARATION ASSIGNATION_OP NEW_OP EXPRESSION SEMICOLON ;
ASSIGNATION_INS                  ::= EXPRESSION ASSIGNATION_OP EXPRESSION SEMICOLON ;
ASSIGNATION_INS                  ::= EXPRESSION ASSIGNATION_OP NEW_OP EXPRESSION SEMICOLON ;

// If

IF_INS      ::= IF PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ELSE_INS ;
ELSE_INS    ::= ELSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;
ELSE_INS    ::= /*EMPTY*/ ;

// Switch

SWITCH_INS        ::= SWITCH PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN CASES_INS DEFAULT_CASE BRACKET_CLOSE ;
CASES_INS         ::= CASES_INS CASE PARENTESIS_OPEN LITERAL PARENTESIS_CLOSE COLON FUNCTION_BODY ;
CASES_INS         ::= /*EMPTY*/;
DEFAULT_CASE      ::= DEFAULT COLON FUNCTION_BODY BREAK SEMICOLON ;

// While

WHILE_INS      ::= WHILE PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;
BREAK_INS      ::= BREAK SEMICOLON ;
CONTINUE_INS   ::= CONTINUE SEMICOLON ;

// For

FOR_INS  ::= FOR PARENTESIS_OPEN OPTIONAL_EXPRESSION SEMICOLON EXPRESSION SEMICOLON OPTIONAL_EXPRESSION PARENTESIS_CLOSE BRACKET_OPEN FUNCTION_BODY BRACKET_CLOSE ;
OPTIONAL_EXPRESSION  ::= EXPRESSION ;
OPTIONAL_EXPRESSION  ::= /*EMPTY*/ ; // TODO Ã±apa

// I/O

IO_INS  ::= INPUT_INS ;
IO_INS  ::= OUTPUT_INS ;
INPUT_INS   ::= INPUT_FUNC PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE SEMICOLON ;
OUTPUT_INS  ::= OUTPUT_FUNC PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE SEMICOLON ;

// Main

MAIN_INS    ::= FUNCTION_DEF MAIN PARENTESIS_OPEN PARENTESIS_CLOSE COLON INT_T BRACKET_OPEN FUNCTION_BODY RETURN INTEGER SEMICOLON BRACKET_CLOSE ;

// Boolean and arithmetic expresions

EXPRESSION        ::= B0 ;

B0                ::= B1 LESS_OR_EQ_OP B1 ;
// {: RESULT = fact; :};
B0                ::= B1 GREATER_OR_EQ_OP B1 ;
B0                ::= B1 LESS_OP B1 ;
B0                ::= B1 GREATER_OP B1 ;
B0                ::= B1 EQUAL_OP B1 ;
B0                ::= B1 NOT_EQUAL_OP B1 ;
B0                ::= B1 ;

B1                ::= B1 OR_OP B2 ;
B1                ::= B2 ;

B2                ::= B2 AND_OP B3 ;
B2                ::= B3 ;

B3                ::= NOT_OP B4 ;
B3                ::= B4 ;

B4                ::= E0 ;

E0                ::= E0 SUM_OP E1 ;
E0                ::= E0 SUBS_OP E1 ;
E0                ::= SUBS_OP E1 ;
E0                ::= E1 ;

E1                ::= E1 MULT_OP E2 ;
E1                ::= E1 DIV_OP E2 ;
E1                ::= E1 MOD_OP E2 ;
E1                ::= E2 ;

E2                ::= E3 POW_OP E3 ;
E2                ::= E3 ;

E3                ::= POINTER_OP E4 ;
E3                ::= E4 ;

E4                ::= E5 FIELD_ACCESS E5 ;
E4                ::= E5 ;

E5                ::= E5 SQ_BRACKET_OPEN EXPRESSION SQ_BRACKET_CLOSE ;
E5                ::= E5 PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE ;
E5                ::= E6 ;

E6                ::= PARENTESIS_OPEN EXPRESSION PARENTESIS_CLOSE ;
E6                ::= TERMINAL ;

EXPRESSIONS          ::= MORE_EXPRESSIONS EXPRESSION ;
EXPRESSION           ::= /*EMPTY*/ ;
MORE_EXPRESSIONS     ::= MORE_EXPRESSIONS EXPRESSION COMMA ;
MORE_EXPRESSIONS     ::= /*EMPTY*/ ;

TERMINAL             ::= LITERAL ;
TERMINAL             ::= ID_EX ;

// Frequently used expresions
TYPE                 ::= INT_T ;
TYPE                 ::= BOOLEAN_T ;
TYPE                 ::= ID ;
TYPE                 ::= TYPE POINTER_OP ;



OPT_INTEGER          ::= INTEGER ;
OPT_INTEGER          ::= ID ;
OPT_INTEGER          ::= /*EMPTY*/ ;

SENTENCE             ::= ASSIGNATION_INS ;
SENTENCE             ::= IF_INS ;
SENTENCE             ::= SWITCH_INS ;
SENTENCE             ::= WHILE_INS ;
SENTENCE             ::= FOR_INS ;
SENTENCE             ::= BREAK_INS ;
SENTENCE             ::= CONTINUE_INS ;
SENTENCE             ::= IO_INS ;
SENTENCE             ::= DECLARATION SEMICOLON ;
SENTENCE             ::= SEMICOLON ; // The last semicolon represents an empty instruction

ID_EX                ::= THIS FIELD_ACCESS ID ;
ID_EX                ::= ID ;

LITERAL              ::= INTEGER ;
LITERAL              ::= TRUE ;
LITERAL              ::= FALSE ;